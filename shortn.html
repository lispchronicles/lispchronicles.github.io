<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <title>Lisp Chronicles/A URL Shortening Service</title>

    <link rel="icon" href="img/lc32.jpg" sizes="32x32" />
    <link rel="icon" href="img/lc192.jpg" sizes="192x192" />
    <link rel="apple-touch-icon-precomposed" href="img/lc180.jpg" />
    
  </head>

  <body>

    <p class="blogtitle"><span class="blogheader">A URL Shortening Service</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="index.html">Home</a>&nbsp;&nbsp;&nbsp;
      <a href="https://twitter.com/lispchronicles" target="_blank">Twitter</a>&nbsp;&nbsp;&nbsp;
      <a href="http://schemer.in" target="_blank">schemer.in</a>&nbsp;&nbsp;&nbsp;
    </p>
    <p class="published">2018-February-07</p>
    
    <p>Recently I came across <a href="http://sparkjava.com/" target="_blank">Spark</a>, a micro framework for developing web applications for the JVM.
      I decided to try it out from Clojure by writing a <a href="https://en.wikipedia.org/wiki/URL_shortening" target="_blank">
        URL shortening service.</a> In addition to showing the implementation of the service, this post will also explore ideas on making such a service
      configurable, reliable and scalable.</p>

    <h3>An Algorithm for Shortening URLs</h3>
    
    <p>The technique for shortening a long URL to a few characters is quite simple: convert the hash of the URL
      to a base-62 value. This is accomplished by the following code:</p>

        <div class="prog">
      <pre><code>
(<span class="kw">def</span> <span class="pw">^String</span> base62-lookup <span class="str">"0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"</span>)

(<span class="kw">defn</span> decimal->b62
  [n]
  (<span class="kw">loop</span> [n n, rs []]
    (<span class="kw">if</span> (zero? n)
      (clojure.string/join (reverse rs))
      (<span class="kw">let</span> [[q r] [(quot n 62) (rem n 62)]]
        (<span class="kw">recur</span> q (conj rs (.charAt base62-lookup (Math/abs r))))))))

(<span class="kw">defn</span> encode
  [<span class="pw">^String</span> url]
  (decimal->b62 (.hashCode url)))
      </code></pre>
        </div>

    <p>To get the shortened version of a URL we just call the <code>encode</code> function on it:</p>
    <div class="prog">
      <pre><code>
> (encode <span class="str">"http://sparkjava.com/documentation"</span>)
<span class="comment">;; "AuV1V"</span>
      </code></pre>
    </div>
    
    <h3>Implementing the Web Service</h3>

    <p>The service should expose two HTTP APIs - one for shortening a URL and the other for generating a redirect to the original
      URL, given the shortened version. Here is the specification for the APIs:</p>

    <div class="prog">
      <pre><code>
<span class="kw">POST</span> /
<b>Request</b>:          
  Content-Type: application/json
  Body: {"url": "a_url"}
<b>Response on Success</b>:
  Status: 200 OK
  Content-Type: application/json
  Body: {"shortUrl": "shortended_version_of_a_url"}

<span class="kw">GET</span> /:short-url
<b>Response on Success</b>:
  Status: 302 Found
  Location: "original_url_from_which_short-url_was_generated"
<b>Response if shortUrl was not generated here</b>:
  Status: 404 Not found
      </code></pre>
    </div>

    <p>Every Spark application has a set of <em>routes</em> which describe its public interface. The HTTP API that we described above can be
      implemented with a <code>get</code> and <code>post</code> routes:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> -main
  []
  (Spark/get <span class="str">"/:short-url"</span> (make-handler get-url-handler))

  (Spark/post <span class="str">"/"</span> (make-handler post-url-handler)))
      </pre></code>
    </div>

    <p>A route has three components - the HTTP verb (get, post, put etc), a path ("/", "/:short-url") and a handler.
      The handler must be an implementation of the <code>Route</code> Java interface. This interface has just one method called <code>handle</code>
      which is invoked to process a client request and generate a response. I defined a convenience function called
      <code>make-handler</code> that can generate an implementation of <code>Route</code> which calls the actual handler function.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> make-handler
  [f]
  (<span class="kw">reify</span> Route
    (handle [_ ^Request request ^Response response]
       (f request response))))
      </code></pre>
    </div>

    <p>Now to the real request handlers themselves. As you might have already noticed in the definition of the <code>handle</code> method above,
      a handler takes <code>Request</code> and <code>Response</code> objects as arguments. First, we will define the handler for the <code>POST</code>
      request. This handler will read the JSON encoded request body, parse it to extract the URL and call the
      <code>encode</code> function on it. This will return the base62 encoded hash of the URL which is send back in the response.
      The function also will map the hash to the original URL in an in-memory lookup table. A <code>GET</code> request can query this table to
      generate the redirect response. The initial implementation of the <code>POST</code> handler is given below:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">def</span> db (atom {}))

(<span class="kw">defn</span> post-url-handler
  [request response]
  (let [r (<a href="https://github.com/dakrone/cheshire" target="_blank">cheshire.core</a>/parse-string (<span class="pw">.body</span> request) <span class="kw">true</span>)
        url (<span class="pw">:url</span> r)
        short-url (encode url)]
    (swap! db assoc short-url url)
    (<span class="pw">.status</span> response 200)
    (<span class="pw">.header</span> response <span class="str">"Content-Type" "application/json"</span>)
    (cheshire.core/generate-string {<span class="pw">:shortUrl</span> short-url})))
      </code></pre>
    </div>

    <p>The <code>GET</code> handler receives a hash (or short-url), lookups up the table for the original URL mapped to it and generates the appropriate
      HTTP redirect response. If no mapping is found for the hash, an HTTP 404 (Not Found) response is returned.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">defn</span> get-url-handler
  [request response]
  (<span class="kw">if-let</span> [url (get @db (<span class="pw">.params</span> request <span class="str">":short-url"</span>))]
    (<span class="pw">.redirect</span> response url)
    (<span class="pw">.status</span> response 404)))
      </code></pre>
    </div>

    <p>The basic URL shortening service is ready! You can download the complete project <a href="./code/url_shortner01.zip">here</a>.
      Execute <code>lein run</code> from the extracted project folder. The service should come up and start listening for incoming
      HTTP requests on port <code>4567</code>. Here are a few <code><a href="https://curl.haxx.se/" target="_blank">curl</a></code>
      sessions to test the service:</p>

    <div class="prog">
      <pre><code>
$ curl -v -X POST -d '{"url": "http://sparkjava.com/documentation#getting-started"}'\
  -H 'Content-Type: application/json' 'http://localhost:4567'

<span class="comment">HTTP/1.1 200 OK          
{"shortUrl":"1BqMVO"}</span>

$ curl -v 'http://localhost:4567/1BqMVO'

<span class="comment">HTTP/1.1 302 Found
Location: http://sparkjava.com/documentation#getting-started</span>
      </code></pre>
    </div>

    <h3>Adding Storage</h3>

    <p>One problem with the current implementation is that the hash->url mappings are stored in the local memory of the service itself.
      If the JVM is shutdown, all data is lost and the users of the service will not be very happy :-). Moreover,
      it becomes impossible to scale the service by running multiple instances of it because there is no
      way to share the mappings between them. So it is necessary to add a storage that can be shared by multiple instances of the service.
      This could be an RDBMS server like MySQL or a key-value store like Couchbase. I will use Couchbase for this example.</p>
    <p>It is straightforward to make the service to talk to a data store like Couchbase which just maps a string key to a string value.
      This model is similar to the one used by the current in-memory store.
      We can add a <code>store</code> abstraction to the service which internally uses
      the <a href="https://github.com/otabat/couchbase-clj" target="_blank">Couchbase client library for Clojure</a> to talk to a Couchbase cluster.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">ns</span> urlshortner.store
  (<span class="pw">:require</span> [couchbase-clj.client :as cb]))

(<span class="kw">defn</span> open-connection
  [props]
  (cb/create-client props))

(<span class="kw">defn</span> close-connection
  [conn]
  (when conn
    (cb/shutdown conn)))

(<span class="kw">defn</span> set-data
  [conn k v]
  (cb/set conn k v))

(<span class="kw">defn</span> get-data
  [conn k]
  (cb/get conn k))
      </code></pre>
    </div>

    <p>The <code>props</code> argument passed to <code>open-connection</code> is a Clojure map that specifies the configuration (username, server urls etc)
      required to connect to the Couchbase cluster. This configuration may change from one deployment site to another. That means, we need our service
      to be able to dynamically load site-specific configuration information. An easy way to manage configuration is to encode it in
      <a href="https://github.com/edn-format/edn" target="_blank">EDN format</a>. Then we can use Clojure's built-in reader and parser to load
      and decode the configuration. This is the code required to load the configuration and extract and pass the Couchbase specific configuration to
      <code>open-connection</code>:</p>

    <div class="prog">
      <pre><code>
(<span class="kw">def</span> config (read-string (slurp <span class="str">"./config.clj"</span>)))

(<span class="kw">def</span> db (store/open-connection (<span class="pw">:store</span> config)))    
      </code></pre>
    </div>

    <p>Contents of the configuration file itself looks like:</p>

    <div class="prog">
      <pre><code>
<span class="comment">;; config.clj</span>
          
{<span class="pw">:web-server-port</span> 8000
 <span class="pw">:store</span>
 {<span class="pw">:username</span> <span class="str">"Administrator"</span>
  <span class="pw">:bucket</span> <span class="str">"default"</span>
  <span class="pw">:op-timeout</span> 100
  <span class="pw">:uris</span> [<span class="str">"http://localhost:8091/pools"</span>]}}
      </code></pre>
    </div>

    <p>Note that we have made the port on which the service listens for incoming requests configurable as well.</p>

    <p>Now we can update <code>post-url-handler</code> to store the mapping in the remote store:</p>

    <div class="prog">
      <pre><code>
(store/set-data db short-url url)
      </code></pre>
    </div>

    <p><code>get-url-handler</code> can lookup its response as:</p>
    <div class="prog">
      <pre><code>
(store/get-data db (<span class="pw">.params</span> request <span class="str">":short-url"</span>))]
      </code></pre>
    </div>

    <p>The <code>-main</code> function has to be updated to start the server on the configured port:</p>

    <div class="prog">
      <pre><code>
(Spark/port (<span class="pw">:web-server-port</span> config))
      </code></pre>
    </div>

    <p>The complete source code for the updated service can be downloaded <a href="./code/url_shortner02.zip">here</a>.
      Now you can start multiple instances of the service, by configuring a unique port number for each.
      You can distribute POST and GET requests across these instances and see them serving the requests from data stored in
      the shared Couchbase cluster.</p>
    
    <h3>Load-balancing and Scaling</h3>

    <p>Let us finish this post by automating the task of load-balancing between the several instances of the service.
      Nginx is a popular HTTP server and <a href="http://nginx.org/en/docs/http/load_balancing.html" target="_blank">load balancer</a>.
      To test out load-balancing on my development box, I added the following to the local nginx configuration:

      <div class="prog">
        <pre><code>
http {
    upstream localhost {
        server localhost:8000;
        server localhost:8002;
    }

    server {
        listen 8080;

        location / {
            proxy_pass http://localhost;
        }
    }
}
        </code></pre>            
      </div>

    <p>The above configuration basically means that nginx will accept connections on port 8080 and forward those
      to the service instances running on port 8000 and 8002 of the same machine. The load-balancing method will
      be round-robin, which is the default.</p>
    
    <p>Start two instances of the URL shortener, one on port 8000 and the other on 8002 and restart nginx.
      The calls for <code>POST http://localhost:8080</code> and <code>GET http://localhost:8080/:short-url</code>
      and will be distributed between the two instances by nginx. To scale the service, just start new instances
      and add them to the <code>upstream</code> configuration.</p>

    <h3>Conclusion</h3>
    <p>Spark provides a simple and clean interface for writing HTTP based services that can be easily integrated with any
      language running on the JVM. Adding a functional wrapper on top of its basic interface may make it more appealing for
      server-side development in Clojure.</p>
    
    <hr></hr>
    <p align="left">
      <a href="https://github.com/lispchronicles/lispchronicles.github.io/issues/1" target="_blank">Comments</a> | <a href="index.html">Home</a>
    </p>
    
  </body>
</html>
