<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <title>Lisp Chronicles/Etudes in Minimalism</title>

    <link rel="icon" href="img/lc32.jpg" sizes="32x32" />
    <link rel="icon" href="img/lc192.jpg" sizes="192x192" />
    <link rel="apple-touch-icon-precomposed" href="img/lc180.jpg" />
    
  </head>

  <body>

    <p class="blogtitle"><span class="blogheader">Etudes in Minimalism</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="index.html">Home</a>&nbsp;&nbsp;&nbsp;
      <a href="https://twitter.com/lispchronicles" target="_blank">Twitter</a>&nbsp;&nbsp;&nbsp;
      <a href="http://schemer.in" target="_blank">schemer.in</a>&nbsp;&nbsp;&nbsp;
    </p>
    <p class="published">2018-November-11</p>

    <p><a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> is a masterpiece of minimalism in
      programming language design. Being a simple language, it never ceases to amaze me with its expressive power. Its most widely
      implemented <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf" target="_blank">standard</a> is only 50 pages
      long and can be read over a weekend. How does such a compactly defined language stack up against large, "industry" languages?
      What is the secret sauce of Scheme's minimal but effective design? These are the questions we will try to answer in this post.
      The insights gained should be applicable to general system design problems.</p>

    <h2>The Power of Lambda!</h2>

    <p>First-class functions are the primary means of abstraction in Scheme. This means functions can be passed as arguments to other functions,
      can be created at will and can be stored in data structures. Scheme functions can potentially make unbounded number of iterative calls
      because Scheme implementations are required to optimize <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank">tail calls</a>.
      This enables the programmer to use tail recursion for expressing iteration and eschews the need for building specialized looping
      constructs (<code>for</code>, <code>while</code> etc) into the core of the language.</p>

    <div class="prog">
      <pre><code>
<span class="comment">;; Sum the elements in a list, utilizing tail recursion.</span>

(<span class="kw">define</span> (sum-list xs sum)
  (<span class="kw">if</span> (null? xs)
    sum
    (sum-list (cdr xs) (+ (car xs) sum))))

(sum-list '(1 2 3 4 5) 0)
<span class="comment">;;=> 15</span>
      </code></pre>
    </div>

    <p>As functions are first-class, <code>sum-list</code> can be defined as a general function that "reduces" lists to a single value
      using a user-specified operation. This operation can be passed as an argument to the function.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (reduce xs init opr)
  (<span class="kw">if</span> (null? xs)
  init
  (reduce (cdr xs) (opr (car xs) init) opr)))

<span class="comment">;; Same as sum-list</span>
(reduce '(1 2 3 4 5) 0 +)
<span class="comment">;;=> 15</span>

(reduce '(1 2 3 4 5) 1 *)
<span class="comment">;;=> 120</span>

(<span class="kw">define</span> (square x) (* x x))

(reduce '(1 2 3 4 5) 1 (<span class="kw">lambda</span> (x y) (+ (square x) (square y))))
<span class="comment">;;=> 28569050</span>
      </code></pre>
    </div>

    <h2>Lexical Scope</h2>

    <p>Scheme is one of the earliest languages to support lexial scoping of variables. This means, all variable bind to the values given
      to them in the context they were defined. These bindings do not change even if the defining context is invoked from other parts
      of the program. The following program demonstrates the immense possiblities that comes with lexical scoping. It defines a function
      that returns another function. The returned function can refer to the variable bindings in its defining context, even if though it may
      be called from other parts of the program.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-adder base)
  (<span class="kw">lambda</span> (x) (+ base x)))

(<span class="kw">define</span> a5 (make-adder 5))
(<span class="kw">define</span> a10 (make-adder 10))
(a5 20)
<span class="comment">;;=> 25</span>
(a10 20)
<span class="comment">;;=> 30</span>
      </code></pre>
    </div>

    <p>The combination of first-class functions and lexical scoping allows Scheme to express object-based programs. No special syntax or
      language constructs is required to program in this powerful paradigm.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-cat)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) 'meow))))

(<span class="kw">define</span> (make-dog)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) 'bow))))

(<span class="kw">define</span> c (make-cat))
(c 'say-hello)
<span class="comment">;;=> meow</span>
(<span class="kw">define</span> d (make-dog))
(d 'say-hello)
<span class="comment">;;=> bow</span>
      </code></pre>
    </div>

    <h2>Syntactic Abstractions</h2>

    TODO

    <h2>Control-flow Abstractions</h2>

    TODO

  </body>
</html>
