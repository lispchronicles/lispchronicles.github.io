<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <title>Lisp Chronicles/Etudes in Minimalism</title>

    <link rel="icon" href="img/lc32.jpg" sizes="32x32" />
    <link rel="icon" href="img/lc192.jpg" sizes="192x192" />
    <link rel="apple-touch-icon-precomposed" href="img/lc180.jpg" />
    
  </head>

  <body>

    <p class="blogtitle"><span class="blogheader">Etudes in Minimalism</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="index.html">Home</a>&nbsp;&nbsp;&nbsp;
      <a href="https://twitter.com/lispchronicles" target="_blank">Twitter</a>&nbsp;&nbsp;&nbsp;
      <a href="http://schemer.in" target="_blank">schemer.in</a>&nbsp;&nbsp;&nbsp;
    </p>
    <p class="published">2018-November-11</p>

    <p><a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> is a masterpiece of minimalism in
      programming language design. Being a simple language, it never ceases to amaze me with its expressive power. Its most widely
      implemented <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf" target="_blank">standard</a> is only 50 pages
      long and can be read over a weekend. How does such a compactly defined language stack up against large, "industry" languages?
      What is the secret sauce of Scheme's minimal but effective design? These are the questions we will try to answer in this post.
      The insights gained should be applicable to general system design problems.</p>

    <h2>The Power of Lambda!</h2>

    <p>First-class functions are the primary means of abstraction in Scheme. This means functions can be passed as arguments to other functions,
      can be created at will and can be stored in data structures. Scheme functions can potentially make unbounded number of iterative calls
      because Scheme implementations are required to optimize <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank">tail calls</a>.
      This enables the programmer to use tail recursion for expressing iteration and eschews the need for building specialized looping
      constructs (<code>for</code>, <code>while</code> etc) into the core of the language.</p>

    <div class="prog">
      <pre><code>
<span class="comment">;; Sum the elements in a list, utilizing tail recursion.</span>

(<span class="kw">define</span> (sum-list xs sum)
  (<span class="kw">if</span> (null? xs)
    sum
    (sum-list (cdr xs) (+ (car xs) sum))))

(sum-list '(1 2 3 4 5) 0)
<span class="comment">;;=> 15</span>
      </code></pre>
    </div>

    <p>As functions are first-class, <code>sum-list</code> can be defined as a general function that "reduces" lists to a single value
      using a user-specified operation. This operation can be passed as an argument to the function.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (reduce xs init opr)
  (<span class="kw">if</span> (null? xs)
  init
  (reduce (cdr xs) (opr (car xs) init) opr)))

<span class="comment">;; Same as sum-list</span>
(reduce '(1 2 3 4 5) 0 +)
<span class="comment">;;=> 15</span>

(reduce '(1 2 3 4 5) 1 *)
<span class="comment">;;=> 120</span>

(<span class="kw">define</span> (square x) (* x x))

(reduce '(1 2 3 4 5) 1 (<span class="kw">lambda</span> (x y) (+ (square x) (square y))))
<span class="comment">;;=> 28569050</span>
      </code></pre>
    </div>

    <h2>Lexical Scope</h2>

    <p>Scheme is one of the earliest languages to support lexial scoping of variables. This means, all variable bind to the values given
      to them in the context they were defined. These bindings do not change even if the defining context is invoked from other parts
      of the program. The following program demonstrates the immense possiblities that comes with lexical scoping. It defines a function
      that returns another function. The returned function can refer to the variable bindings in its defining context, even if though it may
      be called from other parts of the program.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-adder base)
  (<span class="kw">lambda</span> (x) (+ base x)))

(<span class="kw">define</span> a5 (make-adder 5))
(<span class="kw">define</span> a10 (make-adder 10))
(a5 20)
<span class="comment">;;=> 25</span>
(a10 20)
<span class="comment">;;=> 30</span>
      </code></pre>
    </div>

    <p>The combination of first-class functions and lexical scoping allows Scheme to express object-based programs. No special syntax or
      language constructs is required to program in this powerful paradigm.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-cat)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) <span class="sym">'meow</span>))))

(<span class="kw">define</span> (make-dog)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) <span class="sym">'bow-wow</span>))))

(<span class="kw">define</span> c (make-cat))
(c <span class="sym">'say-hello</span>)
<span class="comment">;;=> meow</span>
(<span class="kw">define</span> d (make-dog))
(d <span class="sym">'say-hello</span>)
<span class="comment">;;=> bow-wow</span>
      </code></pre>
    </div>

    <h2>Syntactic Abstractions</h2>

    <p>It is quite impressive that a combination of a few simple concepts is enough to program in multiple paradigms. But sometimes the
      programs written might need a more natural syntax. For instance, programs will become shorter and easier to maintain if there is
      syntactic support for defining classes of objects. Instead of building in syntax for all possible paradigms, Scheme (like all Lisps)
      allow users to extend the language syntax by a macro system. Scheme's macro system is even more powerful because it is guranteed to be
      <a href="https://en.wikipedia.org/wiki/Hygienic_macro" target="_blank">hygienic</a>. The Scheme macro system respects the lexical
      scoping of the rest of the language. This is assured by special naming and scoping rules for macro expansion and avoids
      common programming errors that can occur in the macro systems of other programming languages. The macro system is also very expressive
      because it allows the programmer to add new syntactic constructs to the language using a simple pattern matching sublanguage.</p>

    <p>Let us extend Scheme to support a language for defining new classes of objects. This extension will add a new construct to
      the language will called <code>define-class</code>. It takes the class name and a list of messages and message implementations as
      arguments. The Scheme macro expander will transform a <code>define-class</code> to a function definition that takes a symbolic
      message as argument and execute the appropriate message implementation.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define-syntax</span> define-class
  (<span class="kw">syntax-rules</span> ()
    ((define-class class-name ((message-name message-body) ...))
     (<span class="kw">define</span> (class-name)
       (<span class="kw">lambda</span> (message)
	 (<span class="kw">case</span> message
	   ((message-name) message-body)
	   ...
	   (<span class="kw">else</span> (error <span class="str">"invalid message"</span> message))))))))

(<span class="kw">define-class</span> cat ((say-hello <span class="sym">'meow</span>)))
(<span class="kw">define-class</span> dog ((say-hello <span class="sym">'bow-wow</span>)))

(<span class="kw">define</span> c (cat))
(<span class="kw">define</span> d (dog))

(c <span class="sym">'say-hello</span>)
<span class="comment">;;=> meow</span>
(d <span class="sym">'say-hello</span>)
<span class="comment">;;=> bow-wow</span>
      </code></pre>
    </div>

    <p><b>Exercise 1:</b> Add attribute support for classes defined by <code>define-class</code>. For instance, it should be possible to
      assign names to the various animal objects, like - <code>(define c (cat 'sassy))</code>. It should be possible to refer and
      update the attributes from messages, e,g: </p>
    <p><pre><code>(c 'name) ;;=> sassy
(c 'set-name 'Sassy)
(c 'name) ;;=> Sassy</code></pre></p>

    <h2>Control-flow Abstractions</h2>

    TODO

  </body>
</html>
