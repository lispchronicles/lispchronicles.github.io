<!DOCTYPE html>
<html>
  <head>
    <meta charset="UTF-8">
    <link rel="stylesheet" href="./style.css" type="text/css" />
    <title>Lisp Chronicles/Etudes in Minimalism</title>

    <link rel="icon" href="img/lc32.jpg" sizes="32x32" />
    <link rel="icon" href="img/lc192.jpg" sizes="192x192" />
    <link rel="apple-touch-icon-precomposed" href="img/lc180.jpg" />
    
  </head>

  <body>

    <p class="blogtitle"><span class="blogheader">Etudes in Minimalism</span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
      <a href="index.html">Home</a>&nbsp;&nbsp;&nbsp;
      <a href="https://twitter.com/lispchronicles" target="_blank">Twitter</a>&nbsp;&nbsp;&nbsp;
      <a href="http://schemer.in" target="_blank">schemer.in</a>&nbsp;&nbsp;&nbsp;
    </p>
    <p class="published">2018-November-11</p>

    <p><a href="https://en.wikipedia.org/wiki/Scheme_%28programming_language%29">Scheme</a> is a masterpiece of minimalism in
      programming language design. Being a simple language, it never ceases to amaze me with its expressive power. Its most widely
      implemented <a href="https://schemers.org/Documents/Standards/R5RS/r5rs.pdf" target="_blank">standard</a> is only 50 pages
      long and can be read over a weekend. How does such a compactly defined language stack up against large, "industry" languages?
      What is the secret sauce of Scheme's minimal but effective design? These are the questions we will try to answer in this post.
      The insights gained should be applicable to general system design problems.</p>

    <h2>Lambda the Powerful!</h2>

    <p>First-class functions are the primary means of abstraction in Scheme. This means functions can be passed as arguments to other functions,
      can be created at will and can be stored in data structures. Scheme functions can potentially make unbounded number of iterative calls
      because Scheme implementations are required to optimize <a href="https://en.wikipedia.org/wiki/Tail_call" target="_blank">tail calls</a>.
      This enables the programmer to use tail recursion for expressing iteration and eschews the need for building specialized looping
      constructs (<code>for</code>, <code>while</code> etc) into the core of the language.</p>

    <div class="prog">
      <pre><code>
<span class="comment">;; Sum the elements in a list, utilizing tail recursion.</span>

(<span class="kw">define</span> (sum-list xs sum)
  (<span class="kw">if</span> (null? xs)
    sum
    (sum-list (cdr xs) (+ (car xs) sum))))

(sum-list '(1 2 3 4 5) 0)
<span class="comment">;;=> 15</span>
      </code></pre>
    </div>

    <p>As functions are first-class, <code>sum-list</code> can be defined as a general function that "reduces" lists to a single value
      using a user-specified operation. This operation can be passed as an argument to the function.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (reduce xs init opr)
  (<span class="kw">if</span> (null? xs)
  init
  (reduce (cdr xs) (opr (car xs) init) opr)))

<span class="comment">;; Same as sum-list</span>
(reduce '(1 2 3 4 5) 0 +)
<span class="comment">;;=> 15</span>

(reduce '(1 2 3 4 5) 1 *)
<span class="comment">;;=> 120</span>

(<span class="kw">define</span> (square x) (* x x))

(reduce '(1 2 3 4 5) 1 (<span class="kw">lambda</span> (x y) (+ (square x) (square y))))
<span class="comment">;;=> 28569050</span>
      </code></pre>
    </div>

    <h2>Lexical Scope</h2>

    <p>Scheme is one of the earliest languages to support lexical scoping of variables. This means, all variable bind to the values given
      to them in the context they were defined. These bindings do not change even if the defining context is invoked from other parts
      of the program. The following program demonstrates the immense possibilities that comes with lexical scoping. It defines a function
      that returns another function. The returned function can refer to the variable bindings in its defining context, even if though it may
      be called from other parts of the program.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-adder base)
  (<span class="kw">lambda</span> (x) (+ base x)))

(<span class="kw">define</span> a5 (make-adder 5))
(<span class="kw">define</span> a10 (make-adder 10))
(a5 20)
<span class="comment">;;=> 25</span>
(a10 20)
<span class="comment">;;=> 30</span>
      </code></pre>
    </div>

    <p>The combination of first-class functions and lexical scoping allows Scheme to express object-based programs. No special syntax or
      language constructs is required to program in this powerful paradigm.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> (make-cat)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) <span class="sym">'meow</span>))))

(<span class="kw">define</span> (make-dog)
  (<span class="kw">lambda</span> (message)
    (<span class="kw">case</span> message
      ((say-hello) <span class="sym">'bow-wow</span>))))

(<span class="kw">define</span> c (make-cat))
(c <span class="sym">'say-hello</span>)
<span class="comment">;;=> meow</span>
(<span class="kw">define</span> d (make-dog))
(d <span class="sym">'say-hello</span>)
<span class="comment">;;=> bow-wow</span>
      </code></pre>
    </div>

    (<a href="./func.html" target="_blank">Read more</a> about functional abstractions).

    <h2>Syntactic Abstractions</h2>

    <p>It is quite impressive that a combination of a few simple concepts is enough to program in multiple paradigms. But sometimes the
      programs written might need a more natural syntax. For instance, programs will become shorter and easier to maintain if there is
      syntactic support for defining classes of objects. Instead of building in syntax for all possible paradigms, Scheme (like all Lisps)
      allow users to extend the language syntax by a macro system. Scheme's macro system is even more powerful because it is guaranteed to be
      <a href="https://en.wikipedia.org/wiki/Hygienic_macro" target="_blank">hygienic</a>. The Scheme macro system respects the lexical
      scoping of the rest of the language. This is assured by special naming and scoping rules for macro expansion and avoids
      common programming errors that can occur in the macro systems of other programming languages. The macro system is also very expressive
      because it allows the programmer to add new syntactic constructs to the language using a simple pattern matching sub-language.</p>

    <p>Let us extend Scheme to support a language for defining new classes of objects. This extension will add a new construct to
      the language will called <code>define-class</code>. It takes the class name and a list of messages and message implementations as
      arguments. The Scheme macro expander will transform a <code>define-class</code> to a function definition that takes a symbolic
      message as argument and execute the appropriate message implementation.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define-syntax</span> define-class
  (<span class="kw">syntax-rules</span> ()
    ((define-class class-name ((message-name message-body) ...))
     (<span class="kw">define</span> (class-name)
       (<span class="kw">lambda</span> (message)
	 (<span class="kw">case</span> message
	   ((message-name) message-body)
	   ...
	   (<span class="kw">else</span> (error <span class="str">"invalid message"</span> message))))))))

(<span class="kw">define-class</span> cat ((say-hello <span class="sym">'meow</span>)))
(<span class="kw">define-class</span> dog ((say-hello <span class="sym">'bow-wow</span>)))

(<span class="kw">define</span> c (cat))
(<span class="kw">define</span> d (dog))

(c <span class="sym">'say-hello</span>)
<span class="comment">;;=> meow</span>
(d <span class="sym">'say-hello</span>)
<span class="comment">;;=> bow-wow</span>
      </code></pre>
    </div>

    <p><strong>Exercise 1</strong>: Add attribute support for classes defined by <code>define-class</code>. For instance, it should be possible to
      assign names to the various animal objects, like - <code>(define c (cat 'sassy))</code>. It should be possible to refer and
      update the attributes from messages, e,g: </p>
    <p><pre><code>(c 'name) ;;=> sassy
(c 'set-name 'Sassy)
(c 'name) ;;=> Sassy</code></pre></p>

    (<a href="./syn.html" target="_blank">Read more</a> about building syntactic abstractions in Lisp).

    <h2>Control-flow Abstractions</h2>

    <p>The previous sections showed how a pragmatic language can be designed on top of only a couple of simple building blocks.
      First-class functions and macros can be combined together in intuitive ways to extend and adapt the language to suit
      almost any problem domain. But Scheme does not stop with these. It also allows the programmer to get access to the control state of
      the program and add extensions to the language that control the way the program's execution flows. Scheme allows the capture of
      the current state of the control flow as a function. If this function is called from another part of the program, control will go back
      to the place where it was captured and the program will continue executing from there.</p>

    <p>The presence of first-class continuations means Scheme do not need built-in support for features like exceptions and coroutines.
      These can be implemented added to the language as libraries.</p>

    <p>We will conclude this post with two examples of using continuations. The first one shows the implementation of a simple coroutine
      mechanism.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> continue <span class="pw">#f</span>)

(<span class="kw">define</span> (f)
  (display <span class="str">"f: hello\n"</span>)
  (<span class="kw">call/cc</span>
   (<span class="kw">lambda</span> (k)
     (set! continue k)
     (g)))
  (display <span class="str">"bye bye!\n"</span>))

(<span class="kw">define</span> (g)
  (display <span class="str">"g: hello\n"</span>)
  (continue))

(f)
<span class="comment">;;-> f: hello
;;-> g: hello
;;-> bye bye!</span>
      </code></pre>
    </div>

    <p>The continuation captured in the function <code>f</code> allows the function <code>g</code> to restart <code>f</code> from where it
      left off. This code can become the basis for a more feature-full multitasking library.</p>

    <p>The second example combines continuations with functions and macros to implements an exception handling mechanism.
      Basically, the error handlers are continuations which are made to replace the current state of program execution when an
      exception is raised.</p>

    <div class="prog">
      <pre><code>
(<span class="kw">define</span> handlers '())

(<span class="kw">define</span> (top-handler)
  (car handlers))

(<span class="kw">define</span> (pop-handlers!)
  (<span class="kw">if</span> (not (null? handlers))
      (set! handlers (cdr handlers))))

(<span class="kw">define</span> no-handlers? null?)

(<span class="kw">define</span> (exception msg)
  (<span class="kw">if</span> (no-handlers? handlers)
      (error msg)
      (<span class="kw">let</span> ((handler (top-handler)))
	(handler (cons <span class="sym">'error</span> msg)))))

(<span class="kw">define</span> (prepare-handler handler)
  (pop-handlers!)
  (<span class="kw">lambda</span> (obj)
    (<span class="kw">if</span> (<span class="kw">and</span> (pair? obj) (eq? <span class="sym">'error</span> (car obj)))
	(handler obj)
	obj)))

(<span class="kw">define-syntax</span> with-handler
  (<span class="kw">syntax-rules</span> ()
    ((with-handler handler body ...)
     ((prepare-handler handler)
      (<span class="kw">call/cc</span>
       (<span class="kw">lambda</span> (k)
	 (set! handlers (cons k handlers))
	 body
	 ...))))))


<span class="comment">;; Example usage:</span>
(<span class="kw">define</span> (f x y)
  (<span class="kw">if</span> (= y 0)
    (exception <span class="str">"cannot divide by zero"</span>)
    (/ x y)))

(with-handler
   (<span class="kw">lambda</span> (ex)
     (format <span class="pw">#t</span> <span class="str">"~A\n"</span> ex))
   (display (f 10 20))
   (display <span class="str">" -- done!\n"</span>))
<span class="comment">;;-> 1/2 -- done!</span>

(with-handler
   (<span class="kw">lambda</span> (ex)
     (format <span class="pw">#t</span> <span class="str">"~A\n"</span> ex))
   (display (f 10 20))
   (display <span class="str">" -- done!\n"</span>))
<span class="comment">;;-> (error . cannot divide by zero)</span>
</code></pre>
</div>


    <h2>Conclusion</h2>
    <p>Scheme is truly the Lego of the programming world. Strict, first-class functions with lexically scoped variable bindings
      are the primary building material here. You combine and compose them in various patterns to build abstractions of immense power.
      You build them fast because the semantics of function definition and application is simple to understand and easy to reason about.
      You get abstractions with <a href="https://ecraven.github.io/r7rs-benchmarks/" target="_blank">good performance</a>
      because good Scheme implementations take special care to optimize function calls. Add hygienic macros and continuations to the toolbox
      and you have unlimited power at your disposal. You can build the right abstractions at the right level and write code in
      a language tailor-made to suit the problem at hand. Indeed Scheme is a triumph of minimalism in language design and engineering!</p>
  </body>
</html>
